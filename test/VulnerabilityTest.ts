import { ethers, ignition, network } from "hardhat";
import ReentrancyAttackerModule from "../ignition/modules/ReentrancyAttackerModule";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import {
  FixedVulnerableScopeTwoToken__factory,
  ReentrancyAttacker__factory,
  VulnerableScopeTwoToken__factory,
} from "../typechain-types";
import { expect } from "chai";
import VulnerableScopeTwoTokenModule from "../ignition/modules/VulnerableScopeTwoTokenModule";
import FixedVulnerableScopeTwoTokenModule from "../ignition/modules/FixedVulnerableScopeTwoTokenModule";

describe("VulnerableScopeTwoTokenTests", () => {
  async function deployReentrancyAttackerWithVulnerableToken() {
    const [owner, addr1, addr2] = await ethers.getSigners();

    const { attacker, vulnerableToken, fixedVulnerableToken } =
      await ignition.deploy(ReentrancyAttackerModule);

    const typedAttacker = ReentrancyAttacker__factory.connect(await attacker.getAddress(), owner);
    const typedVulnerableToken = VulnerableScopeTwoToken__factory.connect(
      await vulnerableToken.getAddress(),
      owner,
    );
    const fixedTypedVulnerableToken = FixedVulnerableScopeTwoToken__factory.connect(
      await fixedVulnerableToken.getAddress(),
      owner,
    );

    await typedAttacker.setAttacksCount(30);

    await typedVulnerableToken.setInitialPrice(ethers.parseEther("1.0"));
    await fixedTypedVulnerableToken.setInitialPrice(ethers.parseEther("1.0"));

    return {
      attacker: typedAttacker,
      vulnerableToken: typedVulnerableToken,
      fixedVulnerableToken: fixedTypedVulnerableToken,
      addr1,
      addr2,
    };
  }

  async function deployContractsForDosAttack() {
    const [owner, ...users] = await ethers.getSigners();

    const { vulnerableToken } = await ignition.deploy(VulnerableScopeTwoTokenModule);
    const { fixedVulnerableToken } = await ignition.deploy(FixedVulnerableScopeTwoTokenModule);

    const typedVulnerableToken = VulnerableScopeTwoToken__factory.connect(
      await vulnerableToken.getAddress(),
      owner,
    );
    const typedFixedVulnerableToken = FixedVulnerableScopeTwoToken__factory.connect(
      await fixedVulnerableToken.getAddress(),
      owner,
    );

    await typedVulnerableToken.setInitialPrice(ethers.parseEther("1.0"));
    await typedFixedVulnerableToken.setInitialPrice(ethers.parseEther("1.0"));

    return {
      vulnerableToken: typedVulnerableToken,
      fixedVulnerableToken: typedFixedVulnerableToken,
      owner,
      users,
    };
  }

  describe("DOS attack", () => {
    it(`because of many voters, function call must be expensive and new gas price 
            is expected to be 2 or more times more than initial with increasing owners`, async () => {
      const { vulnerableToken, owner, users } = await loadFixture(deployContractsForDosAttack);

      await vulnerableToken.connect(owner).buy({ value: ethers.parseEther("1000.0") });

      console.log("users amount: ", users.length);

      for (const user of users) {
        await vulnerableToken.connect(owner).transfer(user, 500);
        await vulnerableToken.connect(user)["vote(bool)"](true);
      }

      await vulnerableToken.connect(owner).startVoting();

      await network.provider.send("evm_increaseTime", [3600]);
      await network.provider.send("evm_mine");

      await vulnerableToken.connect(users[0])["vote(uint256)"](200);
      const estimatedGas = await vulnerableToken.connect(owner).endVoting.estimateGas();
      console.log("estimated end voting gas amoutn with one voter: ", estimatedGas);

      for (const user of users.slice(1)) {
        await vulnerableToken.connect(user)["vote(uint256)"](200);
      }

      const newEstimatedGas = await vulnerableToken.connect(owner).endVoting.estimateGas();
      console.log("estimated end voting gas amoutn with a lot of voters: ", newEstimatedGas);

      expect(newEstimatedGas / estimatedGas).to.be.greaterThanOrEqual(2);
    });

    it(`because of many voters, function call must cost the same as with 1 user (O(1))`, async () => {
      const { fixedVulnerableToken, owner, users } = await loadFixture(deployContractsForDosAttack);

      await fixedVulnerableToken.connect(owner).buy({ value: ethers.parseEther("1000.0") });

      console.log("users amount: ", users.length);

      for (const user of users) {
        await fixedVulnerableToken.connect(owner).transfer(user, 500);
        await fixedVulnerableToken.connect(user)["vote(bool)"](true);
      }

      await fixedVulnerableToken.connect(owner).startVoting();

      await network.provider.send("evm_increaseTime", [3600]);
      await network.provider.send("evm_mine");

      await fixedVulnerableToken.connect(users[0])["vote(uint256)"](200);
      const estimatedGas = await fixedVulnerableToken.connect(owner).endVoting.estimateGas();
      console.log("estimated end voting gas amoutn with one voter: ", estimatedGas);

      for (const user of users.slice(1)) {
        await fixedVulnerableToken.connect(user)["vote(uint256)"](200);
      }

      const newEstimatedGas = await fixedVulnerableToken.connect(owner).endVoting.estimateGas();
      console.log("estimated end voting gas amoutn with a lot of voters: ", newEstimatedGas);

      expect(newEstimatedGas / estimatedGas).to.be.lessThanOrEqual(2);
    });
  });

  describe("Reentrancy", async () => {
    it("should be reentrant and drain", async () => {
      const { attacker, vulnerableToken, addr1, addr2 } = await loadFixture(
        deployReentrancyAttackerWithVulnerableToken,
      );

      await vulnerableToken.connect(addr1).buy({ value: ethers.parseEther("10.0") });
      await vulnerableToken.connect(addr2).buy({ value: ethers.parseEther("20.0") });

      const initialAttackerBalance = await ethers.provider.getBalance(attacker.getAddress());
      console.log("initial attacker balance in eth ", initialAttackerBalance);

      await attacker.buySomeTokens(false, { value: ethers.parseEther("1.0") });

      const legitAttackerBalance = await vulnerableToken.balanceOf(attacker);
      const bal1 = await vulnerableToken.balanceOf(addr1);
      const bal2 = await vulnerableToken.balanceOf(addr2);

      console.log("balance of attacker in tokens ", legitAttackerBalance);
      console.log("balance of addr1 in tokens ", bal1);
      console.log("balance of addr2 in tokens ", bal2);

      expect(legitAttackerBalance).to.be.greaterThan(0);

      let drainedContractBalance = await ethers.provider.getBalance(vulnerableToken.getAddress());
      let attackerContractBalance = await ethers.provider.getBalance(attacker.getAddress());

      console.log(
        "drained contract balance before attack in eth ",
        ethers.formatEther(drainedContractBalance),
      );
      console.log(
        "attacker contract balance before attack in eth ",
        ethers.formatEther(attackerContractBalance),
      );

      await vulnerableToken.addListener("VulnerableTransfer", (amount) => {
        console.log("eth amount transfered ", ethers.formatEther(amount));
      });

      await attacker.attack(100, false);

      drainedContractBalance = await ethers.provider.getBalance(vulnerableToken.getAddress());
      attackerContractBalance = await ethers.provider.getBalance(attacker.getAddress());

      console.log(
        "drained contract balance after attack in eth ",
        ethers.formatEther(drainedContractBalance),
      );
      console.log(
        "attacker contract balance after attack in eth ",
        ethers.formatEther(attackerContractBalance),
      );

      expect(drainedContractBalance).to.be.lessThanOrEqual(1);
      expect(attackerContractBalance).to.be.greaterThanOrEqual(30);
    });

    it("should fail while trying to make reentrancy", async () => {
      const { attacker, fixedVulnerableToken, addr1, addr2 } = await loadFixture(
        deployReentrancyAttackerWithVulnerableToken,
      );

      await fixedVulnerableToken.connect(addr1).buy({ value: ethers.parseEther("10.0") });
      await fixedVulnerableToken.connect(addr2).buy({ value: ethers.parseEther("20.0") });

      const initialAttackerBalance = await ethers.provider.getBalance(attacker.getAddress());
      console.log("initial attacker balance in eth ", initialAttackerBalance);

      await attacker.buySomeTokens(true, { value: ethers.parseEther("1.0") });

      const legitAttackerBalance = await fixedVulnerableToken.balanceOf(attacker);
      const bal1 = await fixedVulnerableToken.balanceOf(addr1);
      const bal2 = await fixedVulnerableToken.balanceOf(addr2);

      console.log("balance of attacker in tokens ", legitAttackerBalance);
      console.log("balance of addr1 in tokens ", bal1);
      console.log("balance of addr2 in tokens ", bal2);

      expect(legitAttackerBalance).to.be.greaterThan(0);

      let drainedContractBalance = await ethers.provider.getBalance(
        fixedVulnerableToken.getAddress(),
      );
      let attackerContractBalance = await ethers.provider.getBalance(attacker.getAddress());

      console.log(
        "drained contract balance before attack in eth ",
        ethers.formatEther(drainedContractBalance),
      );
      console.log(
        "attacker contract balance before attack in eth ",
        ethers.formatEther(attackerContractBalance),
      );

      await expect(attacker.attack(100, true)).to.revertedWithPanic();

      drainedContractBalance = await ethers.provider.getBalance(fixedVulnerableToken.getAddress());
      attackerContractBalance = await ethers.provider.getBalance(attacker.getAddress());

      console.log(
        "drained contract balance after attack in eth ",
        ethers.formatEther(drainedContractBalance),
      );
      console.log(
        "attacker contract balance after attack in eth ",
        ethers.formatEther(attackerContractBalance),
      );
    });
  });
});
