import { ethers, ignition, network } from "hardhat";
import ReentrancyAttackerModule from "../ignition/modules/ReentrancyAttackerModule";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { ReentrancyAttacker, VulnerableScopeTwoToken } from "../typechain-types";
import { expect } from 'chai';
import VulnerableScopeTwoTokenModule from "../ignition/modules/VulnerableScopeTwoTokenModule";

describe('VulnerableScopeTwoTokenTests', () => {

    async function deployReentrancyAttackerWithVulnerableToken() {
        const [, addr1, addr2] = await ethers.getSigners();

        const { attacker, vulnerableToken } = await ignition.deploy(ReentrancyAttackerModule);

        const typedAttacker = attacker as unknown as ReentrancyAttacker;
        const typedVulnerableToken = vulnerableToken as unknown as VulnerableScopeTwoToken;

        await typedAttacker.setAttacksCount(30);

        await typedVulnerableToken.setInitialPrice(ethers.parseEther('1.0'));

        return { attacker: typedAttacker, vulnerableToken: typedVulnerableToken, addr1, addr2 };
    }

    async function deployContractsForDosAttack() {
        const [owner, ...users] = await ethers.getSigners();

        const { vulnerableToken } = await ignition.deploy(VulnerableScopeTwoTokenModule);

        const typedVulnerableToken = vulnerableToken as unknown as VulnerableScopeTwoToken;

        await typedVulnerableToken.setInitialPrice(ethers.parseEther('1.0'));

        return { vulnerableToken: typedVulnerableToken, owner, users };
    }

    describe('Reentrancy', async () => {

        it('should be reentrant and drain', async () => {
            const { attacker, vulnerableToken, addr1, addr2 } = await loadFixture(deployReentrancyAttackerWithVulnerableToken);

            await vulnerableToken.connect(addr1).buy({ value: ethers.parseEther('10.0') });
            await vulnerableToken.connect(addr2).buy({ value: ethers.parseEther('20.0') });

            const initialAttackerBalance = await ethers.provider.getBalance(attacker.getAddress());
            console.log('initial attacker balance in eth ', initialAttackerBalance);

            await attacker.buySomeTokens({ value: ethers.parseEther('1.0') });

            const legitAttackerBalance = await vulnerableToken.balanceOf(attacker);
            const bal1 = await vulnerableToken.balanceOf(addr1);
            const bal2 = await vulnerableToken.balanceOf(addr2);

            console.log('balance of attacker in tokens ', legitAttackerBalance);
            console.log('balance of addr1 in tokens ', bal1);
            console.log('balance of addr2 in tokens ', bal2);

            expect(legitAttackerBalance).to.be.greaterThan(0);

            let drainedContractBalance = await ethers.provider.getBalance(vulnerableToken.getAddress());
            let attackerContractBalance = await ethers.provider.getBalance(attacker.getAddress());

            console.log('drained contract balance before attack in eth ', ethers.formatEther(drainedContractBalance));
            console.log('attacker contract balance before attack in eth ', ethers.formatEther(attackerContractBalance));

            await vulnerableToken.addListener('VulnerableTransfer', (amount) => {
                console.log('eth amount transfered ', ethers.formatEther(amount));
            });

            await attacker.attack(100);

            drainedContractBalance = await ethers.provider.getBalance(vulnerableToken.getAddress());
            attackerContractBalance = await ethers.provider.getBalance(attacker.getAddress());

            console.log('drained contract balance after attack in eth ', ethers.formatEther(drainedContractBalance));
            console.log('attacker contract balance after attack in eth ', ethers.formatEther(attackerContractBalance));

            expect(drainedContractBalance).to.be.lessThanOrEqual(1);
            expect(attackerContractBalance).to.be.greaterThanOrEqual(30);
        });
    });

    describe('DOS attack', () => {
        it(`because of many voters, function call must be expensive and new gas price 
            is expected to be 2 or more times more than initial with increasing owners`, 
            async () => {
            const { vulnerableToken, owner, users } = await loadFixture(deployContractsForDosAttack);

            await vulnerableToken.connect(owner).buy({ value: ethers.parseEther('1000.0') });

            console.log('users amount: ', users.length);

            for(const user of users) {
                await vulnerableToken.connect(owner).transfer(user, 500);
                await vulnerableToken.connect(user)["vote(bool)"](true);
            }

            await vulnerableToken.connect(owner).startVoting();

            await network.provider.send('evm_increaseTime', [3600]);
            await network.provider.send('evm_mine');            
            
            await vulnerableToken.connect(users[0])["vote(uint256)"](200);
            const estimatedGas = await vulnerableToken.connect(owner).endVoting.estimateGas();
            console.log('estimated end voting gas amoutn with one voter: ', estimatedGas);

            for(const user of users.slice(1)) {
                await vulnerableToken.connect(user)["vote(uint256)"](200);
            }

            const newEstimatedGas = await vulnerableToken.connect(owner).endVoting.estimateGas();
            console.log('estimated end voting gas amoutn with a lot of voters: ', newEstimatedGas);

            expect(newEstimatedGas / estimatedGas).to.be.greaterThanOrEqual(2);
        });
    });
});